# 最短路径





![image-20210925214858278](images/最短路汇总.png)



### 单源最短路：

- Dijkstra(堆优化版本$O(mlogn)$)
- 朴素BFS（解决边权为1的情况）
- SPFA（解决存在负环的情况）
- Bellmon-Ford（解决存在边数限制的情况）







### 多源最短路：

- 多源BFS(从多个源点出发，将其看做一个超级源点)
- Floyd算法   $O(n^3)$



## Dijkstra算法

#### 思想：

1. 将未标记的距离源点最近的点加入
2. 将选取到的点t进行标识
3. 用t的点的距离去更新与其存在边的点的距离



**缺点：**

Dijkstra利用了贪心思想，只会尽量使图的最短路最短，所以图不能存在负权



**扩展：**

- 计算最短路的路径数可以使用Dijkstra在更新最短路的时候使用一个$ways$数组顺带更新









## 朴素BFS

**思想：**

1. 每次都选择边的权值为1的邻近点加入队列进行下一次的判断
2. 由于每次都选择边的权值为1，所以首次到达该位置就是该位置距离源点的最短路径



**缺点：**

朴素BFS虽然容易实现，但是只能针对边权为1的情况



扩展：

- 对于某些可以用字符串记录下来的状态（比如数字华容道），可以使用BFS来得到邻近状态切换的最小操作数。



## SPFA

























## Bellman-Ford

思想：

1. 连续进行松弛，每一次都需要走一条边，所以我们更新每次走到某个点的最短距离
2. 若更新$n - 1$次之后还能继续更新，说明图中存在负环



时间复杂度: $O(n * m)$

**注意：**

1. 为了避免发生串联更新的现象，需要使用一个backup数组用于存放上一次的最短距离情况(更新某一个点的最短距离之后又更新其依赖的点)
2. Bellmon-Ford方程适用于求解含有边数限制的最短路问题









# 多源最短路



















## Floyd算法

可以解决小数据量的多源多终点最短路径问题




